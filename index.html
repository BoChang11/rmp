<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Motion Planning - Reeds-Shepp Car by iamprem</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Motion Planning - Reeds-Shepp Car</h1>
      <h2 class="project-tagline">By Sampling Based Methods(RRT &amp; RRT*)</h2>
      <a href="https://github.com/iamprem/rmp" class="btn">View on GitHub</a>
      <a href="https://github.com/iamprem/rmp/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/iamprem/rmp/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="path-planning-for-reeds-shepp-car" class="anchor" href="#path-planning-for-reeds-shepp-car" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Path Planning for Reeds-Shepp Car</h1>

<h2>
<a id="table-of-contents" class="anchor" href="#table-of-contents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Table of Contents</h2>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#model-description">Model Description</a></li>
<li><a href="#limitations">Limitations</a></li>
<li><a href="#collision-detection">Collision Detection</a></li>
<li>
<a href="#path-planning-techniques">Path Planning Techniques</a>

<ul>
<li><a href="#rrt">RRT</a></li>
<li><a href="#rrt-star">RRT*</a></li>
<li><a href="#maneuvers">Type 1 and Type 2 maneuvers</a></li>
</ul>
</li>
<li>
<a href="#results">Results</a>

<ul>
<li><a href="#holonomic-robot">Holonomic Robot</a></li>
<li><a href="#non-holonomic-robot">Non-Holonomic Robot</a></li>
</ul>
</li>
<li>
<a href="#execution-instruction">Execution Instruction</a>

<ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#creating-and-loading-scene">Creating and Loading Scene</a></li>
<li><a href="#running-path-planning-methods">Running Path Planning Methods</a></li>
</ul>
</li>
<li><a href="#source-code">Source Code</a></li>
<li><a href="#future-work">Future Work</a></li>
<li><a href="#references">References</a></li>
</ul>

<h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h2>

<p>The goal of this project is to implement sampling based motion planning 
algorithms such as Rapidly-Exploring Random Tree(RRT) and its variant RRT* for a 
holonomic point robot and a Reeds-Shepp car like robot with 
non-holonomic constraints.</p>

<p>When I was implementing RRT* with non-holonomic constraints, I
noticed that we need to be able to reach a nearby point(q_near) with its 
orientation from the new configuration(q_new). This is mostly impossible to reach
by just trying the six combination of inputs that a Reeds-Shepp Car can
take. So I also implemented <strong><em>Type 1</em></strong> and <strong><em>Type 2</em></strong> maneuvers for a car like 
robot to reach a desired configuration by doing combinations of these two
maneuvers.</p>

<h2>
<a id="model-description" class="anchor" href="#model-description" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Model Description</h2>

<ul>
<li>Robot Model          :   Point Robot and Reeds-Shepp Car(Rigid Body)</li>
<li>Type                             :   Holonomic and Non-Holonomic</li>
<li>Workspace              :   2-D plane with Obstacles</li>
<li>Collision Detection: Axis Aligned Bounding Boxes(Implemented)</li>
</ul>

<h2>
<a id="limitations" class="anchor" href="#limitations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Limitations</h2>

<p>For the non-holonomic case, I'm still defining the robot as point
because of my collision detection methods can only tell whether a point
lies inside the obstacle or not. I didn't implement polygon-polygon 
collision detection methods to facilitate this and also using
existing libraries for collision detection even complicates my data structures.</p>

<h2>
<a id="collision-detection" class="anchor" href="#collision-detection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Collision Detection</h2>

<h3>
<a id="axis-aligned-bounding-box" class="anchor" href="#axis-aligned-bounding-box" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Axis Aligned Bounding Box</h3>

<p>The collision detection method that I implemented and used to check
 collision for the below path planning techniques is Axis aligned 
 bounding boxes. Here every obstacle in the environment is bounded by a 
 rectangle of smallest possible size and checking the robot is inside the
 rectangle while planning the path.</p>

<h2>
<a id="path-planning-techniques" class="anchor" href="#path-planning-techniques" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Path Planning Techniques</h2>

<ul>
<li>RRT</li>
<li>RRT*</li>
<li>Type 1 and Type 2 Maneuvers</li>
</ul>

<h3>
<a id="type-1-and-type-2-maneuvers" class="anchor" href="#type-1-and-type-2-maneuvers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Type 1 and Type 2 Maneuvers</h3>

<p>Type 1: This maneuver is to take the robot from a configuration to another
configuration without changing the orientation(Like parallel parking). </p>

<p><img src="https://raw.githubusercontent.com/iamprem/temp/master/assets/type_1.png" alt="Type 1"></p>

<p>Type 2: This maneuver is to bring a robot from some orientation to a
desired orientation in-place(Like a three-point turn)</p>

<p><img src="https://raw.githubusercontent.com/iamprem/temp/master/assets/type_2.png" alt="Type 2"></p>

<p><strong><em>Images Source: Class Lectures</em></strong></p>

<p>There was a third type of movement is implemented to connect these two
maneuvers to reach the goal exactly. First, type 2 maneuver is done to 
change to desired orientation and then marching forward or backward till it 
finds a point that is exactly parallel to the goal configuration, then 
type 1 maneuver is done to reach the goal configuration. Below GIF shows
type 1, type 2 and marching in cyan, brown and yellow colors respectively
from the simulation.</p>

<p><img src="https://raw.githubusercontent.com/iamprem/temp/master/assets/maneuver_gif.gif" alt="Maneuvers"></p>

<h2>
<a id="results" class="anchor" href="#results" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Results</h2>

<h3>
<a id="holonomic-robot" class="anchor" href="#holonomic-robot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Holonomic Robot</h3>

<h4>
<a id="rrt-with-10000-random-samples" class="anchor" href="#rrt-with-10000-random-samples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RRT with 10000 random samples</h4>

<p><img src="https://raw.githubusercontent.com/iamprem/temp/master/assets/rrt_holo.gif" alt="RRT Holonomic"></p>

<h4>
<a id="rrt-with-10000-random-samples-1" class="anchor" href="#rrt-with-10000-random-samples-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RRT* with 10000 random samples</h4>

<p><img src="https://raw.githubusercontent.com/iamprem/temp/master/assets/rrtstar_holo.gif" alt="RRT Star Holonomic"></p>

<h3>
<a id="non-holonomic-robot" class="anchor" href="#non-holonomic-robot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Non-Holonomic Robot</h3>

<p><strong><em>Yellow Lines near the goal(Red Square) represents the maneuvers performed to reach the goal as desired</em></strong></p>

<h4>
<a id="rrt-with-1000-random-samples" class="anchor" href="#rrt-with-1000-random-samples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RRT with 1000 random samples</h4>

<p><img src="https://raw.githubusercontent.com/iamprem/temp/master/assets/rrt_nonholo.png" alt="RRT Non Holonomic"></p>

<h4>
<a id="rrt-with-1000-random-samples-1" class="anchor" href="#rrt-with-1000-random-samples-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RRT* with 1000 random samples</h4>

<p>The below images shows rewiring step(by doing type1 and type2 maneuvers)
in multiple places.</p>

<p><img src="https://raw.githubusercontent.com/iamprem/temp/master/assets/rrtstar_nonholo.png" alt="RRT Star Non Holonomic"></p>

<h2>
<a id="execution-instruction" class="anchor" href="#execution-instruction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Execution Instruction</h2>

<h3>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dependencies</h3>

<ul>
<li>Python 2.7</li>
<li><a href="http://www.pygame.org/wiki/CompileUbuntu">Pygame</a></li>
<li>Numpy</li>
<li>Ubuntu 14.04 or 15.10</li>
</ul>

<h4>
<a id="to-install-numpy-and-pygame-on-ubuntu" class="anchor" href="#to-install-numpy-and-pygame-on-ubuntu" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>To Install Numpy and Pygame on Ubuntu</h4>

<div class="highlight highlight-source-shell"><pre> sudo apt-get install pip            <span class="pl-c"># Install pip(python package manager)</span>
 sudo pip install -U numpy           <span class="pl-c"># Install Numpy using pip</span>
 sudo apt-get install python-pygame  <span class="pl-c"># Install Pygame using Ubuntu package manager</span></pre></div>

<p><strong><em>Note: This program can also be run on Windows and Mac with appropriate pygame <a href="http://www.pygame.org/download.shtml">installation</a></em></strong></p>

<h3>
<a id="creating-and-loading-scene" class="anchor" href="#creating-and-loading-scene" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating and Loading Scene</h3>

<p>To create scene(2D-environment with obstacles), run the below command from terminal/command prompt.</p>

<div class="highlight highlight-source-shell"><pre> <span class="pl-c1">cd</span> rmp                              <span class="pl-c"># Navigate inside the project folder</span>
 python scene.py                     <span class="pl-c"># Run scene definer</span></pre></div>

<p>In the Screen resulted by running the above command, you can draw shapes by doing any of the following.</p>

<ol>
<li>Click and Drag to draw rectangles (like in MS Paint)</li>
<li>Or Just <strong>click on 3 or more places</strong> on the screen to capture co-ordinates of the polygon and once done press <strong>ENTER</strong> to 
see the polygonal shape(Make sure that you don't drag the mouse while clicking).</li>
</ol>

<p>Once obstacles are defined, Close the window to save the scene to 'scene_01.pkl' file(will be located on the project root directory) </p>

<h3>
<a id="running-path-planning-methods" class="anchor" href="#running-path-planning-methods" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Running Path Planning Methods</h3>

<p>Use <code>playground.py</code> located in project root to test the program.</p>

<h4>
<a id="to-define-initial-and-goal-configurations" class="anchor" href="#to-define-initial-and-goal-configurations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>To Define Initial and Goal configurations</h4>

<p>Change the <code>q_init</code> and <code>q_goal</code> at line 11 and 12 on playground.py. <code>x,y and theta</code> should be in the range <code>(0-800), (0-800)
 and (-3.14, 3.14)</code> respectively.</p>

<div class="highlight highlight-source-python"><pre> playground.py : Line <span class="pl-c1">11</span><span class="pl-k">-</span><span class="pl-c1">12</span>

    q_init <span class="pl-k">=</span> (<span class="pl-c1">100.0</span>, <span class="pl-c1">500.0</span>, <span class="pl-c1">0.0</span>)
    q_goal <span class="pl-k">=</span> (<span class="pl-c1">700.0</span>, <span class="pl-c1">500.0</span>, <span class="pl-k">-</span><span class="pl-c1">2.15</span>)</pre></div>

<h4>
<a id="choose-algorithm" class="anchor" href="#choose-algorithm" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Choose Algorithm</h4>

<p>Uncomment any one line and change parameters to run the required algorithm.</p>

<div class="highlight highlight-source-python"><pre>playground.py : Line <span class="pl-c1">27</span><span class="pl-k">-</span><span class="pl-c1">31</span>

   <span class="pl-c"># Call algorithm</span>
   <span class="pl-c"># rrt_tree = planner.build_rrt(10000, epsilon=5)</span>
   <span class="pl-c"># rrt_tree = planner.build_rrtstar(K=10000, epsilon=5)</span>
   <span class="pl-c"># rrt_tree = planner.nh_build_rrt(K=1000, epsilon=40)</span>
   <span class="pl-c"># rrt_tree = planner.nh_build_rrtstar(K=1000, epsilon=40)</span></pre></div>

<p><strong><em>Warning: Non-Holonomic cases with K &gt; 1000 might take longer time to produce result because of inefficient graph
plotting</em></strong></p>

<p>Once you uncommented the algorithm in this step, uncomment/comment the required plotting line to see the result.</p>

<h4>
<a id="holonomic-plot" class="anchor" href="#holonomic-plot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Holonomic Plot</h4>

<p>For Holonomic cases, Uncomment the below lines and comment the Lines (51-57) shown in the next step(Non-Holonomic Plot)</p>

<div class="highlight highlight-source-python"><pre>playground.py : Line <span class="pl-c1">45</span><span class="pl-k">-</span><span class="pl-c1">47</span>

   <span class="pl-c"># q_goal_vtx = planner.reach_goal(rrt_tree, q_goal)</span>
   <span class="pl-c"># vizer.plot_graph(rrt_tree, q_init)</span>
   <span class="pl-c"># vizer.trace_path(q_goal_vtx)</span></pre></div>

<h4>
<a id="non-holonomic-plot" class="anchor" href="#non-holonomic-plot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Non-Holonomic Plot</h4>

<p>For Non-Holonomic Case, comment the three lines (45-47) and uncomment lines (51-57)</p>

<div class="highlight highlight-source-python"><pre>playground.py : Lines <span class="pl-c1">51</span><span class="pl-k">-</span><span class="pl-c1">57</span>

   vizer.nh_plot_graph(rrt_tree, q_init)
   vizer.nh_trace_path(rrt_tree.getVertex(q_nearest))

   a,b,c,d <span class="pl-k">=</span> planner.nh_reach_goal(q_nearest, q_goal)
   final_list <span class="pl-k">=</span> planner.append_t1_m_t2(a, b, c)
   <span class="pl-c"># <span class="pl-k">TODO</span> final_list collision check</span>
   vizer.plot_points(final_list, vizer.<span class="pl-c1">YELLOW</span>, <span class="pl-c1">3</span>)</pre></div>

<h4>
<a id="start-and-stop" class="anchor" href="#start-and-stop" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Start and Stop</h4>

<p>After selecting the appropriate lines from the above steps, </p>

<ul>
<li>run <strong><em><code>python playground.py</code></em></strong> to start the program.</li>
<li>Close the window to exit the program once done(Or Press CTRL + C on console to break)</li>
</ul>

<h2>
<a id="source-code" class="anchor" href="#source-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Source Code</h2>

<p><a href="http://github.com/iamprem/rmp">On Github</a></p>

<h2>
<a id="future-work" class="anchor" href="#future-work" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Future Work</h2>

<ul>
<li>Improve Collision detection to more accurate methods and define the car as a polygon instead of point.</li>
<li>Type 1 and Type 2 maneuvers should be optimized to reduce number of intermediate steps</li>
<li>Implement bidirectional RRTs</li>
</ul>

<h2>
<a id="references" class="anchor" href="#references" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>References</h2>

<ol>
<li>Karaman, Sertac, and Emilio Frazzoli. "Incremental sampling-based algorithms for optimal motion planning." arXiv preprint arXiv:1005.0416 (2010).</li>
<li>Karaman, Sertac, and Emilio Frazzoli. "Sampling-based algorithms for optimal motion planning." The International Journal of Robotics Research 30.7 (2011): 846-894.</li>
<li>Karaman, Sertac, and Emilio Frazzoli. "Optimal kinodynamic motion planning using incremental sampling-based methods." Decision and Control (CDC), 2010 49th IEEE Conference on. IEEE, 2010.</li>
<li>Karaman, Sertac, and Emilio Frazzoli. "Sampling-based optimal motion planning for non-holonomic dynamical systems." Robotics and Automation (ICRA), 2013 IEEE International Conference on. IEEE, 2013.</li>
</ol>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/iamprem/rmp">Motion Planning - Reeds-Shepp Car</a> is maintained by <a href="https://github.com/iamprem">iamprem</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
